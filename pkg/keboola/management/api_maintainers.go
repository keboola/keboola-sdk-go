/*
Manage API

The Keboola Connection Management API covers all tasks required for managing projects, as well as some super admin features for controlling and monitoring Keboola Connection.  ## Projects Management  * Create, modify and delete maintainers, organizations and projects  * Move projects between organizations  * Define project limits  * Provision Redshift and other Storage backends  * Access project management activity log  ## Projects Monitoring  * Monitoring of projects over organizations and maintainers  ## Super User Control and Monitoring  * UI release and deployment  * Components management  * Storage and Syrup jobs monitoring (will be provided by Syrup utilizing new tokens for authorization)  * Final project delete  * Workers start/shutdown, etc.  ## Authentication  The API supports authentication by a personal access token, which can be retrieved in [Account Settings](https://connection.keboola.com/admin/account/change-password) in Keboola Connection. An access token is tied to an administrator and its permissions are derived from their permissions. When the administrator is disabled or deleted, all their tokens become invalid too.  ## Token Types  There are the following types of tokens:  | Name | Tied to User | Token string is available only on create | Description  | | ------------- | ------------- | ------------------- | ----- | | user | Yes | Yes |Full access to maintainers, organizations and projects. Access is limited only to resources which are available for the token user.| | super | No | Yes | KBC management. Limited scopes can be specified `super_ui_deploy`, `super_monitoring`, ...  |

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package management

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// MaintainersAPIService MaintainersAPI service
type MaintainersAPIService service

type ApiAddAUserToMaintainerRequest struct {
	ctx context.Context
	ApiService *MaintainersAPIService
	maintainerId float32
	addAUserToMaintainerRequest *AddAUserToMaintainerRequest
}

func (r ApiAddAUserToMaintainerRequest) AddAUserToMaintainerRequest(addAUserToMaintainerRequest AddAUserToMaintainerRequest) ApiAddAUserToMaintainerRequest {
	r.addAUserToMaintainerRequest = &addAUserToMaintainerRequest
	return r
}

func (r ApiAddAUserToMaintainerRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddAUserToMaintainerExecute(r)
}

/*
AddAUserToMaintainer Add a User to maintainer

Either `id` or `email` of a user must be set. If the email is not associated with a user, a new account is created and an invitation is sent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param maintainerId ID of the maintainer
 @return ApiAddAUserToMaintainerRequest
*/
func (a *MaintainersAPIService) AddAUserToMaintainer(ctx context.Context, maintainerId float32) ApiAddAUserToMaintainerRequest {
	return ApiAddAUserToMaintainerRequest{
		ApiService: a,
		ctx: ctx,
		maintainerId: maintainerId,
	}
}

// Execute executes the request
func (a *MaintainersAPIService) AddAUserToMaintainerExecute(r ApiAddAUserToMaintainerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintainersAPIService.AddAUserToMaintainer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/maintainers/{maintainer_id}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"maintainer_id"+"}", url.PathEscape(parameterValueToString(r.maintainerId, "maintainerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addAUserToMaintainerRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCancelMaintainerInvitationRequest struct {
	ctx context.Context
	ApiService *MaintainersAPIService
	maintainerId string
	invitationId string
}

func (r ApiCancelMaintainerInvitationRequest) Execute() (*http.Response, error) {
	return r.ApiService.CancelMaintainerInvitationExecute(r)
}

/*
CancelMaintainerInvitation Cancel maintainer invitation



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param maintainerId Maintainer ID
 @param invitationId User ID
 @return ApiCancelMaintainerInvitationRequest
*/
func (a *MaintainersAPIService) CancelMaintainerInvitation(ctx context.Context, maintainerId string, invitationId string) ApiCancelMaintainerInvitationRequest {
	return ApiCancelMaintainerInvitationRequest{
		ApiService: a,
		ctx: ctx,
		maintainerId: maintainerId,
		invitationId: invitationId,
	}
}

// Execute executes the request
func (a *MaintainersAPIService) CancelMaintainerInvitationExecute(r ApiCancelMaintainerInvitationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintainersAPIService.CancelMaintainerInvitation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/maintainers/{maintainer_id}/invitations/{invitation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"maintainer_id"+"}", url.PathEscape(parameterValueToString(r.maintainerId, "maintainerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invitation_id"+"}", url.PathEscape(parameterValueToString(r.invitationId, "invitationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateAMaintainerRequest struct {
	ctx context.Context
	ApiService *MaintainersAPIService
	createAMaintainerRequest *CreateAMaintainerRequest
}

func (r ApiCreateAMaintainerRequest) CreateAMaintainerRequest(createAMaintainerRequest CreateAMaintainerRequest) ApiCreateAMaintainerRequest {
	r.createAMaintainerRequest = &createAMaintainerRequest
	return r
}

func (r ApiCreateAMaintainerRequest) Execute() (*MaintainerModel, *http.Response, error) {
	return r.ApiService.CreateAMaintainerExecute(r)
}

/*
CreateAMaintainer Create a maintainer

Creates a new maintainer. The user associated with the token will become an admin of the maintainer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAMaintainerRequest
*/
func (a *MaintainersAPIService) CreateAMaintainer(ctx context.Context) ApiCreateAMaintainerRequest {
	return ApiCreateAMaintainerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MaintainerModel
func (a *MaintainersAPIService) CreateAMaintainerExecute(r ApiCreateAMaintainerRequest) (*MaintainerModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MaintainerModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintainersAPIService.CreateAMaintainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/maintainers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAMaintainerRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAMaintainerRequest struct {
	ctx context.Context
	ApiService *MaintainersAPIService
	maintainerId int32
}

func (r ApiDeleteAMaintainerRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAMaintainerExecute(r)
}

/*
DeleteAMaintainer Delete a maintainer



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param maintainerId 
 @return ApiDeleteAMaintainerRequest
*/
func (a *MaintainersAPIService) DeleteAMaintainer(ctx context.Context, maintainerId int32) ApiDeleteAMaintainerRequest {
	return ApiDeleteAMaintainerRequest{
		ApiService: a,
		ctx: ctx,
		maintainerId: maintainerId,
	}
}

// Execute executes the request
func (a *MaintainersAPIService) DeleteAMaintainerExecute(r ApiDeleteAMaintainerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintainersAPIService.DeleteAMaintainer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/maintainers/{maintainer_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"maintainer_id"+"}", url.PathEscape(parameterValueToString(r.maintainerId, "maintainerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInviteAUserToAMaintainerRequest struct {
	ctx context.Context
	ApiService *MaintainersAPIService
	maintainerId string
	inviteAUserToAMaintainerRequest *InviteAUserToAMaintainerRequest
}

func (r ApiInviteAUserToAMaintainerRequest) InviteAUserToAMaintainerRequest(inviteAUserToAMaintainerRequest InviteAUserToAMaintainerRequest) ApiInviteAUserToAMaintainerRequest {
	r.inviteAUserToAMaintainerRequest = &inviteAUserToAMaintainerRequest
	return r
}

func (r ApiInviteAUserToAMaintainerRequest) Execute() (*InviteAUserToAMaintainer201Response, *http.Response, error) {
	return r.ApiService.InviteAUserToAMaintainerExecute(r)
}

/*
InviteAUserToAMaintainer Invite a user to a maintainer

Only members of the maintainer and superadmins can invite other users.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param maintainerId Maintainer ID
 @return ApiInviteAUserToAMaintainerRequest
*/
func (a *MaintainersAPIService) InviteAUserToAMaintainer(ctx context.Context, maintainerId string) ApiInviteAUserToAMaintainerRequest {
	return ApiInviteAUserToAMaintainerRequest{
		ApiService: a,
		ctx: ctx,
		maintainerId: maintainerId,
	}
}

// Execute executes the request
//  @return InviteAUserToAMaintainer201Response
func (a *MaintainersAPIService) InviteAUserToAMaintainerExecute(r ApiInviteAUserToAMaintainerRequest) (*InviteAUserToAMaintainer201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InviteAUserToAMaintainer201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintainersAPIService.InviteAUserToAMaintainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/maintainers/{maintainer_id}/invitations"
	localVarPath = strings.Replace(localVarPath, "{"+"maintainer_id"+"}", url.PathEscape(parameterValueToString(r.maintainerId, "maintainerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inviteAUserToAMaintainerRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListMaintainerMetadataRequest struct {
	ctx context.Context
	ApiService *MaintainersAPIService
	maintainerId string
}

func (r ApiListMaintainerMetadataRequest) Execute() (*http.Response, error) {
	return r.ApiService.ListMaintainerMetadataExecute(r)
}

/*
ListMaintainerMetadata List maintainer metadata

Only members of the maintainer and super admins can list metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param maintainerId Maintainer ID
 @return ApiListMaintainerMetadataRequest
*/
func (a *MaintainersAPIService) ListMaintainerMetadata(ctx context.Context, maintainerId string) ApiListMaintainerMetadataRequest {
	return ApiListMaintainerMetadataRequest{
		ApiService: a,
		ctx: ctx,
		maintainerId: maintainerId,
	}
}

// Execute executes the request
func (a *MaintainersAPIService) ListMaintainerMetadataExecute(r ApiListMaintainerMetadataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintainersAPIService.ListMaintainerMetadata")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/maintainers/{maintainer_id}/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"maintainer_id"+"}", url.PathEscape(parameterValueToString(r.maintainerId, "maintainerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListMaintainerUsersRequest struct {
	ctx context.Context
	ApiService *MaintainersAPIService
	maintainerId float32
}

func (r ApiListMaintainerUsersRequest) Execute() ([]ListMaintainersInvitations200ResponseInnerUser, *http.Response, error) {
	return r.ApiService.ListMaintainerUsersExecute(r)
}

/*
ListMaintainerUsers List maintainer users



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param maintainerId ID of the maintainer
 @return ApiListMaintainerUsersRequest
*/
func (a *MaintainersAPIService) ListMaintainerUsers(ctx context.Context, maintainerId float32) ApiListMaintainerUsersRequest {
	return ApiListMaintainerUsersRequest{
		ApiService: a,
		ctx: ctx,
		maintainerId: maintainerId,
	}
}

// Execute executes the request
//  @return []ListMaintainersInvitations200ResponseInnerUser
func (a *MaintainersAPIService) ListMaintainerUsersExecute(r ApiListMaintainerUsersRequest) ([]ListMaintainersInvitations200ResponseInnerUser, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ListMaintainersInvitations200ResponseInnerUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintainersAPIService.ListMaintainerUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/maintainers/{maintainer_id}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"maintainer_id"+"}", url.PathEscape(parameterValueToString(r.maintainerId, "maintainerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListMaintainersRequest struct {
	ctx context.Context
	ApiService *MaintainersAPIService
}

func (r ApiListMaintainersRequest) Execute() (*http.Response, error) {
	return r.ApiService.ListMaintainersExecute(r)
}

/*
ListMaintainers List maintainers



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListMaintainersRequest
*/
func (a *MaintainersAPIService) ListMaintainers(ctx context.Context) ApiListMaintainersRequest {
	return ApiListMaintainersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MaintainersAPIService) ListMaintainersExecute(r ApiListMaintainersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintainersAPIService.ListMaintainers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/maintainers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListMaintainersInvitationsRequest struct {
	ctx context.Context
	ApiService *MaintainersAPIService
	maintainerId string
}

func (r ApiListMaintainersInvitationsRequest) Execute() ([]ListMaintainersInvitations200ResponseInner, *http.Response, error) {
	return r.ApiService.ListMaintainersInvitationsExecute(r)
}

/*
ListMaintainersInvitations List maintainers invitations



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param maintainerId Maintainer ID
 @return ApiListMaintainersInvitationsRequest
*/
func (a *MaintainersAPIService) ListMaintainersInvitations(ctx context.Context, maintainerId string) ApiListMaintainersInvitationsRequest {
	return ApiListMaintainersInvitationsRequest{
		ApiService: a,
		ctx: ctx,
		maintainerId: maintainerId,
	}
}

// Execute executes the request
//  @return []ListMaintainersInvitations200ResponseInner
func (a *MaintainersAPIService) ListMaintainersInvitationsExecute(r ApiListMaintainersInvitationsRequest) ([]ListMaintainersInvitations200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ListMaintainersInvitations200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintainersAPIService.ListMaintainersInvitations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/maintainers/{maintainer_id}/invitations"
	localVarPath = strings.Replace(localVarPath, "{"+"maintainer_id"+"}", url.PathEscape(parameterValueToString(r.maintainerId, "maintainerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMaintainerInvitationDetailRequest struct {
	ctx context.Context
	ApiService *MaintainersAPIService
	maintainerId string
	invitationId string
}

func (r ApiMaintainerInvitationDetailRequest) Execute() (*InviteAUserToAMaintainer201Response, *http.Response, error) {
	return r.ApiService.MaintainerInvitationDetailExecute(r)
}

/*
MaintainerInvitationDetail Maintainer invitation detail



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param maintainerId Maintainer ID
 @param invitationId User ID
 @return ApiMaintainerInvitationDetailRequest
*/
func (a *MaintainersAPIService) MaintainerInvitationDetail(ctx context.Context, maintainerId string, invitationId string) ApiMaintainerInvitationDetailRequest {
	return ApiMaintainerInvitationDetailRequest{
		ApiService: a,
		ctx: ctx,
		maintainerId: maintainerId,
		invitationId: invitationId,
	}
}

// Execute executes the request
//  @return InviteAUserToAMaintainer201Response
func (a *MaintainersAPIService) MaintainerInvitationDetailExecute(r ApiMaintainerInvitationDetailRequest) (*InviteAUserToAMaintainer201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InviteAUserToAMaintainer201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintainersAPIService.MaintainerInvitationDetail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/maintainers/{maintainer_id}/invitations/{invitation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"maintainer_id"+"}", url.PathEscape(parameterValueToString(r.maintainerId, "maintainerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invitation_id"+"}", url.PathEscape(parameterValueToString(r.invitationId, "invitationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveAUserFromMaintainerRequest struct {
	ctx context.Context
	ApiService *MaintainersAPIService
	maintainerId float32
	userId string
}

func (r ApiRemoveAUserFromMaintainerRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveAUserFromMaintainerExecute(r)
}

/*
RemoveAUserFromMaintainer Remove a user from maintainer



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param maintainerId ID of the maintainer
 @param userId User ID
 @return ApiRemoveAUserFromMaintainerRequest
*/
func (a *MaintainersAPIService) RemoveAUserFromMaintainer(ctx context.Context, maintainerId float32, userId string) ApiRemoveAUserFromMaintainerRequest {
	return ApiRemoveAUserFromMaintainerRequest{
		ApiService: a,
		ctx: ctx,
		maintainerId: maintainerId,
		userId: userId,
	}
}

// Execute executes the request
func (a *MaintainersAPIService) RemoveAUserFromMaintainerExecute(r ApiRemoveAUserFromMaintainerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintainersAPIService.RemoveAUserFromMaintainer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/maintainers/{maintainer_id}/users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"maintainer_id"+"}", url.PathEscape(parameterValueToString(r.maintainerId, "maintainerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveMaintainerMetadataRequest struct {
	ctx context.Context
	ApiService *MaintainersAPIService
	maintainerId string
	metadataId string
}

func (r ApiRemoveMaintainerMetadataRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveMaintainerMetadataExecute(r)
}

/*
RemoveMaintainerMetadata Remove maintainer metadata



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param maintainerId Maintainer ID
 @param metadataId Metadata ID
 @return ApiRemoveMaintainerMetadataRequest
*/
func (a *MaintainersAPIService) RemoveMaintainerMetadata(ctx context.Context, maintainerId string, metadataId string) ApiRemoveMaintainerMetadataRequest {
	return ApiRemoveMaintainerMetadataRequest{
		ApiService: a,
		ctx: ctx,
		maintainerId: maintainerId,
		metadataId: metadataId,
	}
}

// Execute executes the request
func (a *MaintainersAPIService) RemoveMaintainerMetadataExecute(r ApiRemoveMaintainerMetadataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintainersAPIService.RemoveMaintainerMetadata")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/maintainers/{maintainer_id}/metadata/{metadata_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"maintainer_id"+"}", url.PathEscape(parameterValueToString(r.maintainerId, "maintainerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metadata_id"+"}", url.PathEscape(parameterValueToString(r.metadataId, "metadataId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRetrieveAMaintainerRequest struct {
	ctx context.Context
	ApiService *MaintainersAPIService
	maintainerId int32
}

func (r ApiRetrieveAMaintainerRequest) Execute() (*MaintainerModel, *http.Response, error) {
	return r.ApiService.RetrieveAMaintainerExecute(r)
}

/*
RetrieveAMaintainer Retrieve a maintainer



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param maintainerId 
 @return ApiRetrieveAMaintainerRequest
*/
func (a *MaintainersAPIService) RetrieveAMaintainer(ctx context.Context, maintainerId int32) ApiRetrieveAMaintainerRequest {
	return ApiRetrieveAMaintainerRequest{
		ApiService: a,
		ctx: ctx,
		maintainerId: maintainerId,
	}
}

// Execute executes the request
//  @return MaintainerModel
func (a *MaintainersAPIService) RetrieveAMaintainerExecute(r ApiRetrieveAMaintainerRequest) (*MaintainerModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MaintainerModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintainersAPIService.RetrieveAMaintainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/maintainers/{maintainer_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"maintainer_id"+"}", url.PathEscape(parameterValueToString(r.maintainerId, "maintainerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetMaintainerMetadataRequest struct {
	ctx context.Context
	ApiService *MaintainersAPIService
	maintainerId string
	setMaintainerMetadataRequest *SetMaintainerMetadataRequest
}

func (r ApiSetMaintainerMetadataRequest) SetMaintainerMetadataRequest(setMaintainerMetadataRequest SetMaintainerMetadataRequest) ApiSetMaintainerMetadataRequest {
	r.setMaintainerMetadataRequest = &setMaintainerMetadataRequest
	return r
}

func (r ApiSetMaintainerMetadataRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetMaintainerMetadataExecute(r)
}

/*
SetMaintainerMetadata Set maintainer metadata

Sets multiple metadata with one call. If the given key and provider combination already exist
for the maintainer, the data will be updated with the new value and timestamp.
Only maintainer members and super admins can change metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param maintainerId Maintainer ID
 @return ApiSetMaintainerMetadataRequest
*/
func (a *MaintainersAPIService) SetMaintainerMetadata(ctx context.Context, maintainerId string) ApiSetMaintainerMetadataRequest {
	return ApiSetMaintainerMetadataRequest{
		ApiService: a,
		ctx: ctx,
		maintainerId: maintainerId,
	}
}

// Execute executes the request
func (a *MaintainersAPIService) SetMaintainerMetadataExecute(r ApiSetMaintainerMetadataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintainersAPIService.SetMaintainerMetadata")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/maintainers/{maintainer_id}/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"maintainer_id"+"}", url.PathEscape(parameterValueToString(r.maintainerId, "maintainerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.setMaintainerMetadataRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAMaintainerRequest struct {
	ctx context.Context
	ApiService *MaintainersAPIService
	maintainerId int32
	updateAMaintainerRequest *UpdateAMaintainerRequest
}

func (r ApiUpdateAMaintainerRequest) UpdateAMaintainerRequest(updateAMaintainerRequest UpdateAMaintainerRequest) ApiUpdateAMaintainerRequest {
	r.updateAMaintainerRequest = &updateAMaintainerRequest
	return r
}

func (r ApiUpdateAMaintainerRequest) Execute() (*MaintainerModel, *http.Response, error) {
	return r.ApiService.UpdateAMaintainerExecute(r)
}

/*
UpdateAMaintainer Update a maintainer

A partial update of a maintainer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param maintainerId 
 @return ApiUpdateAMaintainerRequest
*/
func (a *MaintainersAPIService) UpdateAMaintainer(ctx context.Context, maintainerId int32) ApiUpdateAMaintainerRequest {
	return ApiUpdateAMaintainerRequest{
		ApiService: a,
		ctx: ctx,
		maintainerId: maintainerId,
	}
}

// Execute executes the request
//  @return MaintainerModel
func (a *MaintainersAPIService) UpdateAMaintainerExecute(r ApiUpdateAMaintainerRequest) (*MaintainerModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MaintainerModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintainersAPIService.UpdateAMaintainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/maintainers/{maintainer_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"maintainer_id"+"}", url.PathEscape(parameterValueToString(r.maintainerId, "maintainerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateAMaintainerRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
