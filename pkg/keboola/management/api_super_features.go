/*
Manage API

The Keboola Connection Management API covers all tasks required for managing projects, as well as some super admin features for controlling and monitoring Keboola Connection.  ## Projects Management  * Create, modify and delete maintainers, organizations and projects  * Move projects between organizations  * Define project limits  * Provision Redshift and other Storage backends  * Access project management activity log  ## Projects Monitoring  * Monitoring of projects over organizations and maintainers  ## Super User Control and Monitoring  * UI release and deployment  * Components management  * Storage and Syrup jobs monitoring (will be provided by Syrup utilizing new tokens for authorization)  * Final project delete  * Workers start/shutdown, etc.  ## Authentication  The API supports authentication by a personal access token, which can be retrieved in [Account Settings](https://connection.keboola.com/admin/account/change-password) in Keboola Connection. An access token is tied to an administrator and its permissions are derived from their permissions. When the administrator is disabled or deleted, all their tokens become invalid too.  ## Token Types  There are the following types of tokens:  | Name | Tied to User | Token string is available only on create | Description  | | ------------- | ------------- | ------------------- | ----- | | user | Yes | Yes |Full access to maintainers, organizations and projects. Access is limited only to resources which are available for the token user.| | super | No | Yes | KBC management. Limited scopes can be specified `super_ui_deploy`, `super_monitoring`, ...  |

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package management

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SUPERFeaturesAPIService SUPERFeaturesAPI service
type SUPERFeaturesAPIService service

type ApiAddAFeatureRequest struct {
	ctx context.Context
	ApiService *SUPERFeaturesAPIService
	template string
	addAProjectFeatureRequest *AddAProjectFeatureRequest
}

func (r ApiAddAFeatureRequest) AddAProjectFeatureRequest(addAProjectFeatureRequest AddAProjectFeatureRequest) ApiAddAFeatureRequest {
	r.addAProjectFeatureRequest = &addAProjectFeatureRequest
	return r
}

func (r ApiAddAFeatureRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddAFeatureExecute(r)
}

/*
AddAFeature Add a feature

*Note: Features have to exist before they can be added to a project template and have to be of the type `project`.*

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param template StringId of project template
 @return ApiAddAFeatureRequest
*/
func (a *SUPERFeaturesAPIService) AddAFeature(ctx context.Context, template string) ApiAddAFeatureRequest {
	return ApiAddAFeatureRequest{
		ApiService: a,
		ctx: ctx,
		template: template,
	}
}

// Execute executes the request
func (a *SUPERFeaturesAPIService) AddAFeatureExecute(r ApiAddAFeatureRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SUPERFeaturesAPIService.AddAFeature")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/project-templates/{template}/features"
	localVarPath = strings.Replace(localVarPath, "{"+"template"+"}", url.PathEscape(parameterValueToString(r.template, "template")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addAProjectFeatureRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAddAProjectFeatureRequest struct {
	ctx context.Context
	ApiService *SUPERFeaturesAPIService
	projectId string
	addAProjectFeatureRequest *AddAProjectFeatureRequest
}

func (r ApiAddAProjectFeatureRequest) AddAProjectFeatureRequest(addAProjectFeatureRequest AddAProjectFeatureRequest) ApiAddAProjectFeatureRequest {
	r.addAProjectFeatureRequest = &addAProjectFeatureRequest
	return r
}

func (r ApiAddAProjectFeatureRequest) Execute() (*ProjectModel, *http.Response, error) {
	return r.ApiService.AddAProjectFeatureExecute(r)
}

/*
AddAProjectFeature Add a project feature

If the parameter `canBeManageByAdmin` of the feature is `false`, project features can be assigned only by a super admin.

If the `canBeManageByAdmin` is `true`, the project features can be set by an admin without super admin privileges.
But this admin must be in the project to which he wants to assign this features with the role `Admin`.

Organization and maintainer admin have no effect and the user needs activated `can-manage-features` feature.

*Note: Features have to exist before they can be added to a project.*

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @return ApiAddAProjectFeatureRequest
*/
func (a *SUPERFeaturesAPIService) AddAProjectFeature(ctx context.Context, projectId string) ApiAddAProjectFeatureRequest {
	return ApiAddAProjectFeatureRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ProjectModel
func (a *SUPERFeaturesAPIService) AddAProjectFeatureExecute(r ApiAddAProjectFeatureRequest) (*ProjectModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProjectModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SUPERFeaturesAPIService.AddAProjectFeature")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/projects/{project_id}/features"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addAProjectFeatureRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddAUserFeatureRequest struct {
	ctx context.Context
	ApiService *SUPERFeaturesAPIService
	userIdOrEmail string
	addAProjectFeatureRequest *AddAProjectFeatureRequest
}

func (r ApiAddAUserFeatureRequest) AddAProjectFeatureRequest(addAProjectFeatureRequest AddAProjectFeatureRequest) ApiAddAUserFeatureRequest {
	r.addAProjectFeatureRequest = &addAProjectFeatureRequest
	return r
}

func (r ApiAddAUserFeatureRequest) Execute() (*AddAUserFeature200Response, *http.Response, error) {
	return r.ApiService.AddAUserFeatureExecute(r)
}

/*
AddAUserFeature Add a user feature

If the parameter `canBeManageByAdmin` of the feature is `false`, project features can be set only by a super admin.
If the `canBeManageByAdmin` parameter of the feature is `true`, the feature can be assigned by an admin without super admin permission,
but he can assign the feature only to himself.

Organization and maintainer admin have no effect.

*Note: Features have to exist before they can be added to a user.*

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userIdOrEmail User ID or email
 @return ApiAddAUserFeatureRequest
*/
func (a *SUPERFeaturesAPIService) AddAUserFeature(ctx context.Context, userIdOrEmail string) ApiAddAUserFeatureRequest {
	return ApiAddAUserFeatureRequest{
		ApiService: a,
		ctx: ctx,
		userIdOrEmail: userIdOrEmail,
	}
}

// Execute executes the request
//  @return AddAUserFeature200Response
func (a *SUPERFeaturesAPIService) AddAUserFeatureExecute(r ApiAddAUserFeatureRequest) (*AddAUserFeature200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AddAUserFeature200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SUPERFeaturesAPIService.AddAUserFeature")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/users/{user_id_or_email}/features"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id_or_email"+"}", url.PathEscape(parameterValueToString(r.userIdOrEmail, "userIdOrEmail")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addAProjectFeatureRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAFeatureRequest struct {
	ctx context.Context
	ApiService *SUPERFeaturesAPIService
	createAFeatureRequest *CreateAFeatureRequest
}

func (r ApiCreateAFeatureRequest) CreateAFeatureRequest(createAFeatureRequest CreateAFeatureRequest) ApiCreateAFeatureRequest {
	r.createAFeatureRequest = &createAFeatureRequest
	return r
}

func (r ApiCreateAFeatureRequest) Execute() (*CreateAFeature201Response, *http.Response, error) {
	return r.ApiService.CreateAFeatureExecute(r)
}

/*
CreateAFeature Create a feature

**Unless there is a specific reason why the feature MUST NOT be present on some stack, implement it through migration.**

To create a new feature, provide the following parameters as JSON in the request body:

If the `canBeManageByAdmin` parameter is true, the token of a user without a super admin role can assign the feature.
In the case of the `project` feature, it must be in the project and have the `Admin` role.
It is not enough to have the maintainer admin or organization admin permission.

In the case of the `admin` role, an admin who does not have super admin privileges can only set the feature for himself.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAFeatureRequest
*/
func (a *SUPERFeaturesAPIService) CreateAFeature(ctx context.Context) ApiCreateAFeatureRequest {
	return ApiCreateAFeatureRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAFeature201Response
func (a *SUPERFeaturesAPIService) CreateAFeatureExecute(r ApiCreateAFeatureRequest) (*CreateAFeature201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAFeature201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SUPERFeaturesAPIService.CreateAFeature")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/features"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAFeatureRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAFeatureRequest struct {
	ctx context.Context
	ApiService *SUPERFeaturesAPIService
	id float32
}

func (r ApiDeleteAFeatureRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAFeatureExecute(r)
}

/*
DeleteAFeature Delete a feature



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID of the feature to delete
 @return ApiDeleteAFeatureRequest
*/
func (a *SUPERFeaturesAPIService) DeleteAFeature(ctx context.Context, id float32) ApiDeleteAFeatureRequest {
	return ApiDeleteAFeatureRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SUPERFeaturesAPIService) DeleteAFeatureExecute(r ApiDeleteAFeatureRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SUPERFeaturesAPIService.DeleteAFeature")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/features/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListFeaturesRequest struct {
	ctx context.Context
	ApiService *SUPERFeaturesAPIService
	template string
}

func (r ApiListFeaturesRequest) Execute() ([]RetrieveAllFeatures200ResponseInner, *http.Response, error) {
	return r.ApiService.ListFeaturesExecute(r)
}

/*
ListFeatures List features

Lists features assigned to a project template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param template StringId of project template
 @return ApiListFeaturesRequest
*/
func (a *SUPERFeaturesAPIService) ListFeatures(ctx context.Context, template string) ApiListFeaturesRequest {
	return ApiListFeaturesRequest{
		ApiService: a,
		ctx: ctx,
		template: template,
	}
}

// Execute executes the request
//  @return []RetrieveAllFeatures200ResponseInner
func (a *SUPERFeaturesAPIService) ListFeaturesExecute(r ApiListFeaturesRequest) ([]RetrieveAllFeatures200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RetrieveAllFeatures200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SUPERFeaturesAPIService.ListFeatures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/project-templates/{template}/features"
	localVarPath = strings.Replace(localVarPath, "{"+"template"+"}", url.PathEscape(parameterValueToString(r.template, "template")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveAFeatureRequest struct {
	ctx context.Context
	ApiService *SUPERFeaturesAPIService
	template string
	feature string
}

func (r ApiRemoveAFeatureRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveAFeatureExecute(r)
}

/*
RemoveAFeature Remove a feature

Removes a feature assigned to a project template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param template StringId of project template
 @param feature Feature name
 @return ApiRemoveAFeatureRequest
*/
func (a *SUPERFeaturesAPIService) RemoveAFeature(ctx context.Context, template string, feature string) ApiRemoveAFeatureRequest {
	return ApiRemoveAFeatureRequest{
		ApiService: a,
		ctx: ctx,
		template: template,
		feature: feature,
	}
}

// Execute executes the request
func (a *SUPERFeaturesAPIService) RemoveAFeatureExecute(r ApiRemoveAFeatureRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SUPERFeaturesAPIService.RemoveAFeature")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/project-templates/{template}/features/{feature}"
	localVarPath = strings.Replace(localVarPath, "{"+"template"+"}", url.PathEscape(parameterValueToString(r.template, "template")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"feature"+"}", url.PathEscape(parameterValueToString(r.feature, "feature")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveAProjectFeatureRequest struct {
	ctx context.Context
	ApiService *SUPERFeaturesAPIService
	projectId string
	feature string
}

func (r ApiRemoveAProjectFeatureRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveAProjectFeatureExecute(r)
}

/*
RemoveAProjectFeature Remove a project feature

If the parameter `canBeManageByAdmin` of the feature is `false`, project features can be removed only by a super admin.

If the `canBeManageByAdmin` is `true`, the project features can be removed by an admin without super admin privileges.
But this admin must be in the project to which he wants to remove this features with the role `Admin`.

Organization and maintainer admin have no effect and the user needs activated `can-manage-features` feature.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @param feature Feature string ID
 @return ApiRemoveAProjectFeatureRequest
*/
func (a *SUPERFeaturesAPIService) RemoveAProjectFeature(ctx context.Context, projectId string, feature string) ApiRemoveAProjectFeatureRequest {
	return ApiRemoveAProjectFeatureRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		feature: feature,
	}
}

// Execute executes the request
func (a *SUPERFeaturesAPIService) RemoveAProjectFeatureExecute(r ApiRemoveAProjectFeatureRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SUPERFeaturesAPIService.RemoveAProjectFeature")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/projects/{project_id}/features/{feature}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"feature"+"}", url.PathEscape(parameterValueToString(r.feature, "feature")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveAUserFeatureRequest struct {
	ctx context.Context
	ApiService *SUPERFeaturesAPIService
	userIdOrEmail string
	feature string
}

func (r ApiRemoveAUserFeatureRequest) Execute() (*AddAUserFeature200Response, *http.Response, error) {
	return r.ApiService.RemoveAUserFeatureExecute(r)
}

/*
RemoveAUserFeature Remove a user feature

If the parameter `canBeManageByAdmin` of the feature is `false`, project features can be removed only by a super admin.
If the `canBeManageByAdmin` parameter of the feature is `true`, the feature can be removed by an admin without super admin permission,
but he can assign the feature only to himself.

Organization and maintainer admin have no effect.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userIdOrEmail User ID or email
 @param feature Feature name
 @return ApiRemoveAUserFeatureRequest
*/
func (a *SUPERFeaturesAPIService) RemoveAUserFeature(ctx context.Context, userIdOrEmail string, feature string) ApiRemoveAUserFeatureRequest {
	return ApiRemoveAUserFeatureRequest{
		ApiService: a,
		ctx: ctx,
		userIdOrEmail: userIdOrEmail,
		feature: feature,
	}
}

// Execute executes the request
//  @return AddAUserFeature200Response
func (a *SUPERFeaturesAPIService) RemoveAUserFeatureExecute(r ApiRemoveAUserFeatureRequest) (*AddAUserFeature200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AddAUserFeature200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SUPERFeaturesAPIService.RemoveAUserFeature")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/users/{user_id_or_email}/features/{feature}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id_or_email"+"}", url.PathEscape(parameterValueToString(r.userIdOrEmail, "userIdOrEmail")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"feature"+"}", url.PathEscape(parameterValueToString(r.feature, "feature")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveAllFeaturesRequest struct {
	ctx context.Context
	ApiService *SUPERFeaturesAPIService
	type_ string
}

func (r ApiRetrieveAllFeaturesRequest) Execute() ([]RetrieveAllFeatures200ResponseInner, *http.Response, error) {
	return r.ApiService.RetrieveAllFeaturesExecute(r)
}

/*
RetrieveAllFeatures Retrieve all features

Gets all features. To filter only the features with a specific type,
add the `type` parameter to your query.

In case the token you are using for the call does not have super admin permissions,
the response will only contain features that have `canBeManageByAdmin: true`, `canBeManagedViaAPI: true` set.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param type_ Type of features you want to filter
 @return ApiRetrieveAllFeaturesRequest
*/
func (a *SUPERFeaturesAPIService) RetrieveAllFeatures(ctx context.Context, type_ string) ApiRetrieveAllFeaturesRequest {
	return ApiRetrieveAllFeaturesRequest{
		ApiService: a,
		ctx: ctx,
		type_: type_,
	}
}

// Execute executes the request
//  @return []RetrieveAllFeatures200ResponseInner
func (a *SUPERFeaturesAPIService) RetrieveAllFeaturesExecute(r ApiRetrieveAllFeaturesRequest) ([]RetrieveAllFeatures200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RetrieveAllFeatures200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SUPERFeaturesAPIService.RetrieveAllFeatures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/features?type={type}"
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveFeatureProjectsRequest struct {
	ctx context.Context
	ApiService *SUPERFeaturesAPIService
	id float32
}

func (r ApiRetrieveFeatureProjectsRequest) Execute() ([]TokenVerification200ResponseCreator, *http.Response, error) {
	return r.ApiService.RetrieveFeatureProjectsExecute(r)
}

/*
RetrieveFeatureProjects Retrieve feature projects

Gets the projects with the specified feature assigned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID of the feature
 @return ApiRetrieveFeatureProjectsRequest
*/
func (a *SUPERFeaturesAPIService) RetrieveFeatureProjects(ctx context.Context, id float32) ApiRetrieveFeatureProjectsRequest {
	return ApiRetrieveFeatureProjectsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []TokenVerification200ResponseCreator
func (a *SUPERFeaturesAPIService) RetrieveFeatureProjectsExecute(r ApiRetrieveFeatureProjectsRequest) ([]TokenVerification200ResponseCreator, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TokenVerification200ResponseCreator
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SUPERFeaturesAPIService.RetrieveFeatureProjects")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/features/{id}/projects"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveFeatureUsersRequest struct {
	ctx context.Context
	ApiService *SUPERFeaturesAPIService
	id float32
}

func (r ApiRetrieveFeatureUsersRequest) Execute() ([]ListMaintainersInvitations200ResponseInnerUser, *http.Response, error) {
	return r.ApiService.RetrieveFeatureUsersExecute(r)
}

/*
RetrieveFeatureUsers Retrieve feature users

Gets the users with the specified feature assigned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID of the feature
 @return ApiRetrieveFeatureUsersRequest
*/
func (a *SUPERFeaturesAPIService) RetrieveFeatureUsers(ctx context.Context, id float32) ApiRetrieveFeatureUsersRequest {
	return ApiRetrieveFeatureUsersRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []ListMaintainersInvitations200ResponseInnerUser
func (a *SUPERFeaturesAPIService) RetrieveFeatureUsersExecute(r ApiRetrieveFeatureUsersRequest) ([]ListMaintainersInvitations200ResponseInnerUser, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ListMaintainersInvitations200ResponseInnerUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SUPERFeaturesAPIService.RetrieveFeatureUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/features/{id}/admins"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveOneFeatureRequest struct {
	ctx context.Context
	ApiService *SUPERFeaturesAPIService
	id float32
}

func (r ApiRetrieveOneFeatureRequest) Execute() (*RetrieveAllFeatures200ResponseInner, *http.Response, error) {
	return r.ApiService.RetrieveOneFeatureExecute(r)
}

/*
RetrieveOneFeature Retrieve one feature

In case your token that you use when calling does not have super admin permissions,
the feature must have parameters `canBeManageByAdmin: true`, `canBeManagedViaAPI: true` set to be able to view its detail.
Otherwise the response will be 404 Not Found.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID of the feature
 @return ApiRetrieveOneFeatureRequest
*/
func (a *SUPERFeaturesAPIService) RetrieveOneFeature(ctx context.Context, id float32) ApiRetrieveOneFeatureRequest {
	return ApiRetrieveOneFeatureRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RetrieveAllFeatures200ResponseInner
func (a *SUPERFeaturesAPIService) RetrieveOneFeatureExecute(r ApiRetrieveOneFeatureRequest) (*RetrieveAllFeatures200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RetrieveAllFeatures200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SUPERFeaturesAPIService.RetrieveOneFeature")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/features/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAFeatureRequest struct {
	ctx context.Context
	ApiService *SUPERFeaturesAPIService
	id float32
	updateAFeatureRequest *UpdateAFeatureRequest
}

func (r ApiUpdateAFeatureRequest) UpdateAFeatureRequest(updateAFeatureRequest UpdateAFeatureRequest) ApiUpdateAFeatureRequest {
	r.updateAFeatureRequest = &updateAFeatureRequest
	return r
}

func (r ApiUpdateAFeatureRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAFeatureExecute(r)
}

/*
UpdateAFeature Update a feature

A partial update of a feature

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID of the feature to update
 @return ApiUpdateAFeatureRequest
*/
func (a *SUPERFeaturesAPIService) UpdateAFeature(ctx context.Context, id float32) ApiUpdateAFeatureRequest {
	return ApiUpdateAFeatureRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SUPERFeaturesAPIService) UpdateAFeatureExecute(r ApiUpdateAFeatureRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SUPERFeaturesAPIService.UpdateAFeature")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/features/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateAFeatureRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
