/*
Manage API

The Keboola Connection Management API covers all tasks required for managing projects, as well as some super admin features for controlling and monitoring Keboola Connection.  ## Projects Management  * Create, modify and delete maintainers, organizations and projects  * Move projects between organizations  * Define project limits  * Provision Redshift and other Storage backends  * Access project management activity log  ## Projects Monitoring  * Monitoring of projects over organizations and maintainers  ## Super User Control and Monitoring  * UI release and deployment  * Components management  * Storage and Syrup jobs monitoring (will be provided by Syrup utilizing new tokens for authorization)  * Final project delete  * Workers start/shutdown, etc.  ## Authentication  The API supports authentication by a personal access token, which can be retrieved in [Account Settings](https://connection.keboola.com/admin/account/change-password) in Keboola Connection. An access token is tied to an administrator and its permissions are derived from their permissions. When the administrator is disabled or deleted, all their tokens become invalid too.  ## Token Types  There are the following types of tokens:  | Name | Tied to User | Token string is available only on create | Description  | | ------------- | ------------- | ------------------- | ----- | | user | Yes | Yes |Full access to maintainers, organizations and projects. Access is limited only to resources which are available for the token user.| | super | No | Yes | KBC management. Limited scopes can be specified `super_ui_deploy`, `super_monitoring`, ...  |

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package management

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SUPERStorageBackendsManagementAPIService SUPERStorageBackendsManagementAPI service
type SUPERStorageBackendsManagementAPIService service

type ApiBackendDetailRequest struct {
	ctx context.Context
	ApiService *SUPERStorageBackendsManagementAPIService
	backendId string
}

func (r ApiBackendDetailRequest) Execute() ([]interface{}, *http.Response, error) {
	return r.ApiService.BackendDetailExecute(r)
}

/*
BackendDetail Backend detail



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param backendId Backend ID
 @return ApiBackendDetailRequest
*/
func (a *SUPERStorageBackendsManagementAPIService) BackendDetail(ctx context.Context, backendId string) ApiBackendDetailRequest {
	return ApiBackendDetailRequest{
		ApiService: a,
		ctx: ctx,
		backendId: backendId,
	}
}

// Execute executes the request
//  @return []interface{}
func (a *SUPERStorageBackendsManagementAPIService) BackendDetailExecute(r ApiBackendDetailRequest) ([]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SUPERStorageBackendsManagementAPIService.BackendDetail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/storage-backend/{backend_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"backend_id"+"}", url.PathEscape(parameterValueToString(r.backendId, "backendId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateANewBackendRequest struct {
	ctx context.Context
	ApiService *SUPERStorageBackendsManagementAPIService
	createANewBackendRequest *CreateANewBackendRequest
}

func (r ApiCreateANewBackendRequest) CreateANewBackendRequest(createANewBackendRequest CreateANewBackendRequest) ApiCreateANewBackendRequest {
	r.createANewBackendRequest = &createANewBackendRequest
	return r
}

func (r ApiCreateANewBackendRequest) Execute() (*CreateANewBackend201Response, *http.Response, error) {
	return r.ApiService.CreateANewBackendExecute(r)
}

/*
CreateANewBackend Create a new backend

Superuser credentials are *not required* for backend registration

#### Redshift

Credentials with superuser access to the database must be provided for Redshift.

#### Snowflake

Credentials and storage warehouse are required. You can generate a user, role and warehouse with the following queries:

```
CREATE ROLE "KEBOOLA_STORAGE";
GRANT CREATE DATABASE ON ACCOUNT TO ROLE "KEBOOLA_STORAGE";
GRANT CREATE ROLE ON ACCOUNT TO ROLE "KEBOOLA_STORAGE" WITH GRANT OPTION;
GRANT CREATE USER ON ACCOUNT TO ROLE "KEBOOLA_STORAGE" WITH GRANT OPTION;
CREATE WAREHOUSE "KEBOOLA" WITH WAREHOUSE_SIZE = 'XSMALL' WAREHOUSE_TYPE = 'STANDARD' AUTO_SUSPEND = 60 AUTO_RESUME = TRUE;
GRANT USAGE ON WAREHOUSE "KEBOOLA" TO ROLE "KEBOOLA_STORAGE" WITH GRANT OPTION;

CREATE USER "KEBOOLA_STORAGE"
    PASSWORD = "YOUR_PASSWORD"
    DEFAULT_ROLE = "KEBOOLA_STORAGE"
    TYPE = LEGACY_SERVICE;

GRANT ROLE "KEBOOLA_STORAGE" TO USER "KEBOOLA_STORAGE";
GRANT ROLE "KEBOOLA_STORAGE" TO ROLE SYSADMIN;
```

If you want to have dynamic backends enabled, please also run the following queries and add `useDynamicBackends: true` in the request.

```
CREATE WAREHOUSE "KEBOOLA_SMALL" WITH
    WAREHOUSE_SIZE = 'SMALL'
    WAREHOUSE_TYPE = 'STANDARD'
    AUTO_SUSPEND = 60
    AUTO_RESUME = TRUE
    MIN_CLUSTER_COUNT = 1
    MAX_CLUSTER_COUNT = 10;
CREATE WAREHOUSE "KEBOOLA_MEDIUM" WITH
    WAREHOUSE_SIZE = 'MEDIUM'
    WAREHOUSE_TYPE = 'STANDARD'
    AUTO_SUSPEND = 60
    AUTO_RESUME = TRUE
    MIN_CLUSTER_COUNT = 1
    MAX_CLUSTER_COUNT = 10;
CREATE WAREHOUSE "KEBOOLA_LARGE" WITH
    WAREHOUSE_SIZE = 'LARGE'
    WAREHOUSE_TYPE = 'STANDARD'
    AUTO_SUSPEND = 60
    AUTO_RESUME = TRUE
    MIN_CLUSTER_COUNT = 1
    MAX_CLUSTER_COUNT = 10;

GRANT USAGE ON WAREHOUSE "KEBOOLA_SMALL" TO ROLE "KEBOOLA_STORAGE" WITH GRANT OPTION;
GRANT USAGE ON WAREHOUSE "KEBOOLA_MEDIUM" TO ROLE "KEBOOLA_STORAGE" WITH GRANT OPTION;
GRANT USAGE ON WAREHOUSE "KEBOOLA_LARGE" TO ROLE "KEBOOLA_STORAGE" WITH GRANT OPTION;
GRANT MONITOR ON WAREHOUSE "KEBOOLA_SMALL" TO ROLE "KEBOOLA_MONITORING" WITH GRANT OPTION;
GRANT MONITOR ON WAREHOUSE "KEBOOLA_MEDIUM" TO ROLE "KEBOOLA_MONITORING" WITH GRANT OPTION;
GRANT MONITOR ON WAREHOUSE "KEBOOLA_LARGE" TO ROLE "KEBOOLA_MONITORING" WITH GRANT OPTION;
```

According to the previous example, the parameters for creating Storage will be:

- `user` - `KEBOOLA_STORAGE`

- `warehouse` - `YOUR_WAREHOUSE`

- `password` - `YOUR_PASSWORD`

#### Synapse

Credentials for sql server admin must be provided with database name.

Master key for exports must be created on SQL pool

```
CREATE MASTER KEY
```

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateANewBackendRequest
*/
func (a *SUPERStorageBackendsManagementAPIService) CreateANewBackend(ctx context.Context) ApiCreateANewBackendRequest {
	return ApiCreateANewBackendRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateANewBackend201Response
func (a *SUPERStorageBackendsManagementAPIService) CreateANewBackendExecute(r ApiCreateANewBackendRequest) (*CreateANewBackend201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateANewBackend201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SUPERStorageBackendsManagementAPIService.CreateANewBackend")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/storage-backend"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createANewBackendRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateANewBigQueryBackendRequest struct {
	ctx context.Context
	ApiService *SUPERStorageBackendsManagementAPIService
	createANewBigQueryBackendRequest *CreateANewBigQueryBackendRequest
}

func (r ApiCreateANewBigQueryBackendRequest) CreateANewBigQueryBackendRequest(createANewBigQueryBackendRequest CreateANewBigQueryBackendRequest) ApiCreateANewBigQueryBackendRequest {
	r.createANewBigQueryBackendRequest = &createANewBigQueryBackendRequest
	return r
}

func (r ApiCreateANewBigQueryBackendRequest) Execute() (*CreateANewBigQueryBackend201Response, *http.Response, error) {
	return r.ApiService.CreateANewBigQueryBackendExecute(r)
}

/*
CreateANewBigQueryBackend Create a new BigQuery backend

You must create a new project and service account in a folder in your organization,
this service account must have the right to create new projects (roles/resourcemanager.projectCreator) in this folder (only in this folder)
and use the generated json [keyFile](https://cloud.google.com/iam/docs/creating-managing-service-account-keys)
for this `service account` in the `credentials` parameter, the folder id then as `folderId`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateANewBigQueryBackendRequest
*/
func (a *SUPERStorageBackendsManagementAPIService) CreateANewBigQueryBackend(ctx context.Context) ApiCreateANewBigQueryBackendRequest {
	return ApiCreateANewBigQueryBackendRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateANewBigQueryBackend201Response
func (a *SUPERStorageBackendsManagementAPIService) CreateANewBigQueryBackendExecute(r ApiCreateANewBigQueryBackendRequest) (*CreateANewBigQueryBackend201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateANewBigQueryBackend201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SUPERStorageBackendsManagementAPIService.CreateANewBigQueryBackend")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/storage-backend/bigquery"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createANewBigQueryBackendRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBackendRequest struct {
	ctx context.Context
	ApiService *SUPERStorageBackendsManagementAPIService
	backendId string
}

func (r ApiDeleteBackendRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteBackendExecute(r)
}

/*
DeleteBackend Delete backend

All projects using the backend must be deleted and purged before it can be deleted

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param backendId Id of storage backend
 @return ApiDeleteBackendRequest
*/
func (a *SUPERStorageBackendsManagementAPIService) DeleteBackend(ctx context.Context, backendId string) ApiDeleteBackendRequest {
	return ApiDeleteBackendRequest{
		ApiService: a,
		ctx: ctx,
		backendId: backendId,
	}
}

// Execute executes the request
func (a *SUPERStorageBackendsManagementAPIService) DeleteBackendExecute(r ApiDeleteBackendRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SUPERStorageBackendsManagementAPIService.DeleteBackend")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/storage-backend/{backend_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"backend_id"+"}", url.PathEscape(parameterValueToString(r.backendId, "backendId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListBackendsRequest struct {
	ctx context.Context
	ApiService *SUPERStorageBackendsManagementAPIService
}

func (r ApiListBackendsRequest) Execute() ([]interface{}, *http.Response, error) {
	return r.ApiService.ListBackendsExecute(r)
}

/*
ListBackends List backends



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListBackendsRequest
*/
func (a *SUPERStorageBackendsManagementAPIService) ListBackends(ctx context.Context) ApiListBackendsRequest {
	return ApiListBackendsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []interface{}
func (a *SUPERStorageBackendsManagementAPIService) ListBackendsExecute(r ApiListBackendsRequest) ([]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SUPERStorageBackendsManagementAPIService.ListBackends")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/storage-backend"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateBackendRequest struct {
	ctx context.Context
	ApiService *SUPERStorageBackendsManagementAPIService
	backendId string
	storageBackendUpdate *StorageBackendUpdate
}

func (r ApiUpdateBackendRequest) StorageBackendUpdate(storageBackendUpdate StorageBackendUpdate) ApiUpdateBackendRequest {
	r.storageBackendUpdate = &storageBackendUpdate
	return r
}

func (r ApiUpdateBackendRequest) Execute() (*CreateANewBackend201Response, *http.Response, error) {
	return r.ApiService.UpdateBackendExecute(r)
}

/*
UpdateBackend Update backend

A partial update of a storage backend, one of the attributes are required.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param backendId Backend ID
 @return ApiUpdateBackendRequest
*/
func (a *SUPERStorageBackendsManagementAPIService) UpdateBackend(ctx context.Context, backendId string) ApiUpdateBackendRequest {
	return ApiUpdateBackendRequest{
		ApiService: a,
		ctx: ctx,
		backendId: backendId,
	}
}

// Execute executes the request
//  @return CreateANewBackend201Response
func (a *SUPERStorageBackendsManagementAPIService) UpdateBackendExecute(r ApiUpdateBackendRequest) (*CreateANewBackend201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateANewBackend201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SUPERStorageBackendsManagementAPIService.UpdateBackend")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/storage-backend/{backend_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"backend_id"+"}", url.PathEscape(parameterValueToString(r.backendId, "backendId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.storageBackendUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateBigQueryBackendRequest struct {
	ctx context.Context
	ApiService *SUPERStorageBackendsManagementAPIService
	backendId string
	bigQueryStorageBackendUpdate *BigQueryStorageBackendUpdate
}

func (r ApiUpdateBigQueryBackendRequest) BigQueryStorageBackendUpdate(bigQueryStorageBackendUpdate BigQueryStorageBackendUpdate) ApiUpdateBigQueryBackendRequest {
	r.bigQueryStorageBackendUpdate = &bigQueryStorageBackendUpdate
	return r
}

func (r ApiUpdateBigQueryBackendRequest) Execute() (*CreateANewBigQueryBackend201Response, *http.Response, error) {
	return r.ApiService.UpdateBigQueryBackendExecute(r)
}

/*
UpdateBigQueryBackend Update BigQuery backend

Update of the credentials for BigQuery backend.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param backendId Backend ID
 @return ApiUpdateBigQueryBackendRequest
*/
func (a *SUPERStorageBackendsManagementAPIService) UpdateBigQueryBackend(ctx context.Context, backendId string) ApiUpdateBigQueryBackendRequest {
	return ApiUpdateBigQueryBackendRequest{
		ApiService: a,
		ctx: ctx,
		backendId: backendId,
	}
}

// Execute executes the request
//  @return CreateANewBigQueryBackend201Response
func (a *SUPERStorageBackendsManagementAPIService) UpdateBigQueryBackendExecute(r ApiUpdateBigQueryBackendRequest) (*CreateANewBigQueryBackend201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateANewBigQueryBackend201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SUPERStorageBackendsManagementAPIService.UpdateBigQueryBackend")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/storage-backend/bigquery/{backend_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"backend_id"+"}", url.PathEscape(parameterValueToString(r.backendId, "backendId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bigQueryStorageBackendUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
