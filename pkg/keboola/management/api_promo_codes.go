/*
Manage API

The Keboola Connection Management API covers all tasks required for managing projects, as well as some super admin features for controlling and monitoring Keboola Connection.  ## Projects Management  * Create, modify and delete maintainers, organizations and projects  * Move projects between organizations  * Define project limits  * Provision Redshift and other Storage backends  * Access project management activity log  ## Projects Monitoring  * Monitoring of projects over organizations and maintainers  ## Super User Control and Monitoring  * UI release and deployment  * Components management  * Storage and Syrup jobs monitoring (will be provided by Syrup utilizing new tokens for authorization)  * Final project delete  * Workers start/shutdown, etc.  ## Authentication  The API supports authentication by a personal access token, which can be retrieved in [Account Settings](https://connection.keboola.com/admin/account/change-password) in Keboola Connection. An access token is tied to an administrator and its permissions are derived from their permissions. When the administrator is disabled or deleted, all their tokens become invalid too.  ## Token Types  There are the following types of tokens:  | Name | Tied to User | Token string is available only on create | Description  | | ------------- | ------------- | ------------------- | ----- | | user | Yes | Yes |Full access to maintainers, organizations and projects. Access is limited only to resources which are available for the token user.| | super | No | Yes | KBC management. Limited scopes can be specified `super_ui_deploy`, `super_monitoring`, ...  |

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package management

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// PromoCodesAPIService PromoCodesAPI service
type PromoCodesAPIService service

type ApiCreateNewPromoCodesRequest struct {
	ctx context.Context
	ApiService *PromoCodesAPIService
	maintainerId int32
	createNewPromoCodesRequest *CreateNewPromoCodesRequest
}

func (r ApiCreateNewPromoCodesRequest) CreateNewPromoCodesRequest(createNewPromoCodesRequest CreateNewPromoCodesRequest) ApiCreateNewPromoCodesRequest {
	r.createNewPromoCodesRequest = &createNewPromoCodesRequest
	return r
}

func (r ApiCreateNewPromoCodesRequest) Execute() (*CreateNewPromoCodes201Response, *http.Response, error) {
	return r.ApiService.CreateNewPromoCodesExecute(r)
}

/*
CreateNewPromoCodes Create new promo codes

To create a new promo-code, provide the following parameters as JSON in the request body:

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param maintainerId 
 @return ApiCreateNewPromoCodesRequest
*/
func (a *PromoCodesAPIService) CreateNewPromoCodes(ctx context.Context, maintainerId int32) ApiCreateNewPromoCodesRequest {
	return ApiCreateNewPromoCodesRequest{
		ApiService: a,
		ctx: ctx,
		maintainerId: maintainerId,
	}
}

// Execute executes the request
//  @return CreateNewPromoCodes201Response
func (a *PromoCodesAPIService) CreateNewPromoCodesExecute(r ApiCreateNewPromoCodesRequest) (*CreateNewPromoCodes201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateNewPromoCodes201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PromoCodesAPIService.CreateNewPromoCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/maintainers/{maintainer_id}/promo-codes"
	localVarPath = strings.Replace(localVarPath, "{"+"maintainer_id"+"}", url.PathEscape(parameterValueToString(r.maintainerId, "maintainerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createNewPromoCodesRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveAllPromoCodesRequest struct {
	ctx context.Context
	ApiService *PromoCodesAPIService
	maintainerId int32
}

func (r ApiRetrieveAllPromoCodesRequest) Execute() ([]RetrieveAllPromoCodes200ResponseInner, *http.Response, error) {
	return r.ApiService.RetrieveAllPromoCodesExecute(r)
}

/*
RetrieveAllPromoCodes Retrieve all promo codes



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param maintainerId 
 @return ApiRetrieveAllPromoCodesRequest
*/
func (a *PromoCodesAPIService) RetrieveAllPromoCodes(ctx context.Context, maintainerId int32) ApiRetrieveAllPromoCodesRequest {
	return ApiRetrieveAllPromoCodesRequest{
		ApiService: a,
		ctx: ctx,
		maintainerId: maintainerId,
	}
}

// Execute executes the request
//  @return []RetrieveAllPromoCodes200ResponseInner
func (a *PromoCodesAPIService) RetrieveAllPromoCodesExecute(r ApiRetrieveAllPromoCodesRequest) ([]RetrieveAllPromoCodes200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RetrieveAllPromoCodes200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PromoCodesAPIService.RetrieveAllPromoCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manage/maintainers/{maintainer_id}/promo-codes"
	localVarPath = strings.Replace(localVarPath, "{"+"maintainer_id"+"}", url.PathEscape(parameterValueToString(r.maintainerId, "maintainerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-KBC-ManageApiToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
